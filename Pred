import pandas as pd
import numpy as np
from datetime import datetime
import re

# Function to convert strings like "Monthly Return 2017-02 Base currency" to datetime
def parse_date(date_str):
    # Extract the year and month from the string using regex
    match = re.search(r'(\d{4})-(\d{2})', date_str)
    if match:
        return datetime.strptime(match.group(0), '%Y-%m')
    else:
        return None

# Function to calculate return statistics (returns, volatility, drawdown)
def calculate_statistics(df, fund_name):
    # Assuming data is in percentage format, 1 = 1%
    df = df / 100

    # Compute the rolling volatility
    volatility_3m = df.rolling(window=3).std().iloc[-1] * np.sqrt(12) * 100
    volatility_6m = df.rolling(window=6).std().iloc[-1] * np.sqrt(12) * 100

    # Compute the returns for different periods
    return_3m = (df.iloc[-3:].prod() - 1) * 100
    return_6m = (df.iloc[-6:].prod() - 1) * 100
    ytd_return = (df[df.index.year == df.index[-1].year].prod() - 1) * 100
    return_3y = (df.iloc[-36:].prod() ** (1/3) - 1) * 100
    return_5y = (df.iloc[-60:].prod() ** (1/5) - 1) * 100

    # Calculate maximum drawdown
    cumulative_returns = (1 + df).cumprod()
    rolling_max = cumulative_returns.cummax()
    drawdown = cumulative_returns / rolling_max - 1
    max_drawdown = drawdown.min() * 100
    peak_date = rolling_max.idxmax()
    trough_date = drawdown.idxmin()
    
    # Check recovery date
    recovery_date = None
    if cumulative_returns.iloc[-1] < rolling_max.max():
        recovery_status = 'Not recovered'
    else:
        recovery_status = 'Recovered'
        recovery_date = cumulative_returns[cumulative_returns >= rolling_max.max()].index[0]

    # Return as a dictionary
    return {
        'Fund': fund_name,
        '3M Return': return_3m.values[0],
        '6M Return': return_6m.values[0],
        'YTD Return': ytd_return.values[0],
        '3Y Annualized Return': return_3y.values[0],
        '5Y Annualized Return': return_5y.values[0],
        '3M Volatility': volatility_3m.values[0],
        '6M Volatility': volatility_6m.values[0],
        'Max Drawdown': max_drawdown.values[0],
        'Peak Date': peak_date,
        'Trough Date': trough_date,
        'Recovery Date': recovery_date,
        'Recovery Status': recovery_status
    }

# Load the data from Excel
file_path = 'your_file_path.xlsx'
df = pd.read_excel(file_path, sheet_name='Sheet2')

# Rename column A (dates)
df['Date'] = df.iloc[:, 0].apply(parse_date)

# Drop the first row since it's empty (as described)
df = df.drop(0)

# Set the Date column as the index
df.set_index('Date', inplace=True)

# Process each fund's data
results = []
for fund in df.columns[1:]:  # Skip the first column (dates)
    fund_data = df[fund].dropna()  # Drop any missing data points
    stats = calculate_statistics(fund_data, fund)
    results.append(stats)

# Convert the results into a DataFrame
results_df = pd.DataFrame(results)

# Save the results to a new Excel file
output_file = 'fund_statistics.xlsx'
results_df.to_excel(output_file, index=False)

print(f"Statistics have been saved to {output_file}.")
