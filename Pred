import pandas as pd
import numpy as np
from datetime import datetime
import scipy.stats as stats

# Function to calculate annualized returns
def annualized_return(returns, periods_per_year):
    compounded_growth = (1 + returns).prod()
    n_periods = len(returns)
    return compounded_growth**(periods_per_year / n_periods) - 1

# Function to calculate volatility (standard deviation) annualized
def annualized_volatility(returns, periods_per_year):
    return returns.std() * np.sqrt(periods_per_year)

# Function to calculate max drawdown
def max_drawdown(returns):
    cumulative = (1 + returns).cumprod()
    peak = cumulative.cummax()
    drawdown = (cumulative - peak) / peak
    max_dd = drawdown.min()

    trough = drawdown.idxmin()
    peak_date = cumulative[:trough].idxmax()

    # Check for recovery
    recovery = np.nan
    if cumulative[trough:].max() >= cumulative[peak_date]:
        recovery = cumulative[trough:].idxmax()
    
    return max_dd, peak_date, trough, recovery

# Reading the Excel file
file_path = "your_file.xlsx"  # Specify the file path
df = pd.read_excel(file_path, sheet_name="Sheet2", header=1)

# Clean column names in case there's extra whitespace or issues
df.columns = df.columns.str.strip()

# Check the name of the first column (likely unnamed, but it may vary)
first_col_name = df.columns[0]

# Convert the first column to dates if it matches the expected pattern
df['Date'] = pd.to_datetime(df[first_col_name].str.extract(r'(\d{4}-\d{2})')[0], format='%Y-%m', errors='coerce')

# Remove rows where the 'Date' is NaT (invalid date)
df = df.dropna(subset=['Date'])

# Set 'Date' as the index
df.set_index('Date', inplace=True)

# Remove the first column as it's no longer needed (date column extracted)
df = df.drop(columns=[first_col_name])

# Remove any non-numeric rows (e.g., headers or footnotes)
df = df.dropna(how='all', axis=0)

# Calculate performance metrics
output = pd.DataFrame()

periods = {
    '3 months': 3,
    '6 months': 6,
    'YTD': df.index.year.unique()[-1],  # Year to Date
    '3 years': 36,  # Assuming 12 periods in a year (monthly data)
    '5 years': 60
}

for fund in df.columns:
    fund_data = {}
    # Get the most recent data and trim for required periods
    recent_data = df[fund].tail(periods['3 years'])
    
    # Calculate returns and volatility for different periods
    for period, months in periods.items():
        period_data = df[fund].tail(months) if isinstance(months, int) else df[df.index.year == months][fund]
        fund_data[f"{period} return"] = (1 + period_data).prod() - 1
        fund_data[f"{period} volatility"] = annualized_volatility(period_data, 12) * 100
    
    # Calculate max drawdown
    max_dd, peak, trough, recovery = max_drawdown(recent_data)
    fund_data['Max Drawdown'] = max_dd * 100
    fund_data['Peak Date'] = peak.strftime('%Y-%m')
    fund_data['Trough Date'] = trough.strftime('%Y-%m')
    fund_data['Recovery Date'] = recovery.strftime('%Y-%m') if not pd.isna(recovery) else 'Not recovered'

    # Append the fund data
    output[fund] = pd.Series(fund_data)

# Write to a new Excel file
output.to_excel("fund_performance_analysis.xlsx", index_label="Metrics")

print("Fund performance metrics saved successfully!")
